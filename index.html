<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tactical Map Editor</title>
    <style>
        :root {
            --neon-blue: #00d4ff;
            --neon-green: #2ecc71;
            --neon-red: #ff4757;
            --neon-purple: #bc13fe;
            --panel-bg: rgba(10, 10, 10, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-glow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        body {
            font-family: 'Orbitron', sans-serif;
            margin: 0; padding: 0;
            display: flex; justify-content: center; align-items: center;
            background: #020406 url('bg.png') no-repeat center center fixed;
            background-size: cover;
            color: #e0e0e0; min-height: 100vh; overflow-x: hidden;
            touch-action: none;
        }

        #boot-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; display: flex; 
            flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s ease-out;
        }

        .boot-text {
            color: var(--neon-blue); font-size: 14px; margin: 5px;
            overflow: hidden; border-right: 2px solid var(--neon-blue);
            white-space: nowrap; width: 0;
            animation: typing 1s steps(30, end) forwards, blink 0.5s step-end infinite;
        }
        @keyframes typing { from { width: 0 } to { width: 300px } }
        @keyframes blink { from, to { border-color: transparent } 50% { border-color: var(--neon-blue) } }

        .main-wrapper {
            display: flex; align-items: stretch; gap: 25px;
            position: relative; z-index: 10;
            animation: fadeIn 1.5s ease-out;
            padding: 20px;
        }

        @media (max-width: 900px) {
            .main-wrapper { flex-direction: column; align-items: center; gap: 15px; padding: 10px; }
            .side-panel { width: 90% !important; flex-direction: row !important; flex-wrap: wrap; justify-content: center; padding: 15px !important; }
            .canvas-container { width: 95vw; height: auto; }
            canvas#map { width: 100% !important; height: auto !important; }
        }

        .side-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 24px;
            width: 240px;
            display: flex; flex-direction: column; gap: 14px;
            box-shadow: var(--accent-glow);
            transition: all 0.3s ease;
        }

        .canvas-container {
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid var(--glass-border);
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
            position: relative;
            background: #000;
        }

        /* Fixed: Progress Bar outside of Map Area */
        .progress-header {
            background: rgba(0,0,0,0.8);
            padding: 10px 0;
            border-bottom: 1px solid var(--glass-border);
            text-align: center;
        }

        button, select, input {
            background: rgba(255,255,255,0.05);
            color: #fff; border: 1px solid var(--glass-border);
            padding: 12px; font-family: 'Orbitron'; font-size: 11px;
            cursor: pointer; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px; text-transform: uppercase; letter-spacing: 1px;
        }

        button:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
        }

        .btn-green { color: var(--neon-green); border-color: rgba(46, 204, 113, 0.3); }
        .btn-green:hover { background: rgba(46, 204, 113, 0.15); box-shadow: 0 0 20px rgba(46, 204, 113, 0.3); }
        .btn-active { background: rgba(0, 212, 255, 0.1); border-color: var(--neon-blue); box-shadow: 0 0 15px var(--neon-blue); }

        .credits-name { display: block; font-size: 18px; font-weight: 900; margin-bottom: 4px; text-align: center; }
        .glow-purple { color: #fff; text-shadow: 0 0 10px var(--neon-purple); }
        .glow-green { color: #fff; text-shadow: 0 0 10px var(--neon-green); }
        .glow-red { color: #fff; text-shadow: 0 0 10px var(--neon-red); }

        .banner-link { margin-top: auto; border-radius: 12px; overflow: hidden; border: 2px solid transparent; transition: 0.3s; background: linear-gradient(45deg, #00d4ff, #bc13fe); padding: 2px; }

        #mission-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 10000;
            justify-content: center; align-items: center; backdrop-filter: blur(12px);
        }
        .modal-box { background: #050505; border: 1px solid var(--neon-blue); padding: 40px; border-radius: 24px; text-align: center; box-shadow: 0 0 100px rgba(0, 212, 255, 0.2); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        canvas { display: block; cursor: crosshair; }
        hr { border: 0; border-top: 1px solid var(--glass-border); margin: 10px 0; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body>

<div id="boot-screen">
    <div class="boot-text">INITIALIZING...</div>
</div>

<div id="mission-modal">
    <div class="modal-box">
        <h1 style="color:var(--neon-blue); font-weight:900;">CLEARED</h1>
        <div style="font-size: 20px; margin: 15px 0;">TIME: <span id="modal-time" style="color:var(--neon-green)">0.00s</span></div>
        <canvas id="modal-preview-canvas" width="800" height="800" style="width:300px; height:300px; border-radius:10px; margin: 20px auto; border: 1px solid #333;"></canvas>
        <button onclick="closeModal()" class="btn-green" style="width: 100%; font-size: 16px; padding: 15px;">CONTINUE</button>
    </div>
</div>

<div class="main-wrapper">
    <div class="side-panel">
        <button onclick="undo()">Undo</button>
        <button onclick="resetRun()" style="color:var(--neon-red)">Reset Run</button>
        
        <div style="padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.2);">
            <div style="font-size: 10px; opacity: 0.6; margin-bottom: 5px;">SPAWN COUNT:</div>
            <input type="number" id="spawnCount" value="40" min="1" max="200" style="width: 85%;">
            <button onclick="generate()" class="btn-green" style="width: 100%; margin-top: 10px;">Spawn Titans</button>
        </div>

        <button onclick="createBlankMap()">Clear Canvas</button>
        <button onclick="exportPreset()">Export Map</button>
        <button onclick="importPreset()">Import Map</button>

        <hr>
        
        <button id="btn-odm" class="btn-active" onclick="setMode('odm')">Draw Mode</button>
        <button id="btn-place" onclick="setMode('place')">Edit Mode</button>
        <select id="titanType">
            <option value="basic">Basic</option>
            <option value="abnormal">Abnormal</option>
        </select>
        <div id="status-msg" style="font-size: 10px; color: var(--neon-blue); text-align: center;">READY</div>
    </div>

    <div class="canvas-container">
        <div class="progress-header">
            <span style="font-size: 10px; letter-spacing: 2px; opacity: 0.7;">PROGRESS:</span>
            <span id="sync-val" style="font-size: 30px; color: var(--neon-green); font-weight: 900; text-shadow: 0 0 15px var(--neon-green);">0</span>
            <span style="color: var(--neon-green); font-weight: 900;">%</span>
        </div>
        <canvas id="map" width="800" height="800"></canvas>
    </div>

    <div class="side-panel">
        <div>
            <div style="font-size: 10px; opacity: 0.6;">TIMER</div>
            <div id="display-time" style="font-size: 28px; color: var(--neon-green); font-weight: 900;">0.00s</div>
        </div>

        <button onclick="toggleGrid()">Toggle Grid</button>
        <button onclick="exportImage()" class="btn-green">Save Image</button>
        
        <div>
            <div style="font-size: 10px; opacity: 0.6;">REMAINING</div>
            <div id="titan-count" style="font-size: 28px; color: var(--neon-blue); font-weight: 900;">0</div>
        </div>

        <div class="credits-container">
            <span class="credits-name glow-purple">kraaxeN</span>
            <span class="credits-name glow-green">Damter</span>
            <span class="credits-name glow-red">Cuternest</span>
        </div>

        <a href="https://www.youtube.com/@kraaxeN" target="_blank" class="banner-link">
            <img src="kraxbanner.png" alt="YouTube" style="width:100%; display:block; border-radius:10px;">
        </a>
    </div>
</div>

<script>
    window.addEventListener('load', () => {
        setTimeout(() => {
            document.getElementById('boot-screen').style.opacity = '0';
            setTimeout(() => { document.getElementById('boot-screen').style.display = 'none'; }, 1000);
        }, 1000);
    });

    let titans = [], paths = [], currentPath = [], drawing = false, grid = true, customMode = false;
    let runCompleted = false, lastPoint = null, hasStarted = false, startTime = null, timerInterval = null;

    const canvas = document.getElementById('map');
    const ctx = canvas.getContext('2d');
    const modalPreviewCanvas = document.getElementById('modal-preview-canvas');
    const mCtx = modalPreviewCanvas.getContext('2d');

    const imgs = { map: new Image(), basic: new Image(), abnormal: new Image(), skull: new Image(), grid: new Image() };
    imgs.map.src = 'outskirts.png'; imgs.basic.src = 'basic.png';
    imgs.abnormal.src = 'abnormal.png'; imgs.skull.src = 'skull.png'; imgs.grid.src = 'grid.png';

    const startZone = { x: 350, y: 720, w: 100, h: 80 };
    const missionPoly = [{x: 320, y: 25}, {x: 600, y: 35}, {x: 765, y: 115}, {x: 775, y: 440}, {x: 770, y: 685}, {x: 630, y: 685}, {x: 520, y: 600}, {x: 400, y: 630}, {x: 180, y: 650}, {x: 115, y: 480}, {x: 100, y: 360}, {x: 230, y: 130}, {x: 290, y: 35}];

    function getCoords(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX; clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX; clientY = e.clientY;
        }
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    function isPointInPoly(pt, poly) {
        let isInside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            if (((poly[i].y > pt.y) !== (poly[j].y > pt.y)) && (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) isInside = !isInside;
        }
        return isInside;
    }

    function createBlankMap() { titans = []; resetRun(); updateUI(); }

    function openModal() {
        document.getElementById('modal-time').textContent = document.getElementById('display-time').textContent;
        mCtx.clearRect(0,0,800,800);
        mCtx.drawImage(imgs.map, 0,0,800,800);
        titans.forEach(t => {
            mCtx.drawImage(t.type === 'basic' ? imgs.basic : imgs.abnormal, t.x-15, t.y-15, 30, 30);
            if(t.dead) mCtx.drawImage(imgs.skull, t.x-12, t.y-12, 24, 24);
        });
        mCtx.strokeStyle = "#00d4ff"; mCtx.lineWidth = 4;
        paths.forEach(p => {
            if(p.length < 2) return;
            mCtx.beginPath(); mCtx.moveTo(p[0].x, p[0].y);
            p.forEach(pt => mCtx.lineTo(pt.x, pt.y)); mCtx.stroke();
        });
        document.getElementById('mission-modal').style.display = 'flex';
    }

    function closeModal() { document.getElementById('mission-modal').style.display = 'none'; resetRun(); }

    function handleDown(e) {
        if (e.touches) e.preventDefault();
        const {x, y} = getCoords(e);
        if (!e.touches && e.button === 2 && customMode) { titans = titans.filter(t => Math.hypot(t.x - x, t.y - y) > 20); updateUI(); return; }
        if (customMode) {
            if (isPointInPoly({x, y}, missionPoly)) { titans.push({x, y, type: document.getElementById('titanType').value, dead: false, skullScale: 0}); updateUI(); }
        } else {
            if (!hasStarted) {
                if (x >= startZone.x && x <= startZone.x + startZone.w && y >= startZone.y && y <= startZone.y + startZone.h) {
                    hasStarted = true; drawing = true; currentPath = [{x, y}]; startTimer(); document.getElementById('status-msg').textContent = "ACTIVE";
                }
            } else if (lastPoint && Math.hypot(x - lastPoint.x, y - lastPoint.y) < 55) { drawing = true; currentPath = [{x, y}]; }
        }
    }

    function handleMove(e) {
        if (!drawing) return;
        if (e.touches) e.preventDefault();
        const {x, y} = getCoords(e);
        currentPath.push({x, y});
        if (currentPath.length >= 2) {
            const p1 = currentPath[currentPath.length-2], p2 = currentPath[currentPath.length-1];
            titans.forEach(t => { if(!t.dead && distToSeg(t, p1, p2) < 22) { t.dead = true; t.skullScale = 3.0; } });
        }
        updateSync();
    }

    function handleUp() {
        if(drawing) {
            paths.push([...currentPath]); lastPoint = currentPath[currentPath.length - 1]; currentPath = []; drawing = false;
            if (document.getElementById('sync-val').textContent === "100" && titans.length > 0 && !runCompleted) { stopTimer(); runCompleted = true; openModal(); }
        }
        updateUI();
    }

    canvas.addEventListener('mousedown', handleDown);
    canvas.addEventListener('touchstart', handleDown, {passive: false});
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('touchmove', handleMove, {passive: false});
    window.addEventListener('mouseup', handleUp);
    window.addEventListener('touchend', handleUp);

    function startTimer() { startTime = Date.now(); timerInterval = setInterval(() => { document.getElementById('display-time').textContent = ((Date.now() - startTime) / 1000).toFixed(2) + "s"; }, 10); }
    function stopTimer() { clearInterval(timerInterval); }

    function undo() {
        if (paths.length > 0) {
            paths.pop(); titans.forEach(t => { t.dead = false; t.skullScale = 0; });
            paths.forEach(p => { for(let i=0; i<p.length-1; i++) { titans.forEach(t => { if(!t.dead && distToSeg(t, p[i], p[i+1]) < 22) { t.dead = true; t.skullScale = 1.0; } }); } });
            if (paths.length > 0) { lastPoint = paths[paths.length - 1].slice(-1)[0]; } else { lastPoint = null; hasStarted = false; stopTimer(); document.getElementById('display-time').textContent = "0.00s"; }
            runCompleted = false; updateUI();
        }
    }

    function resetRun() { stopTimer(); document.getElementById('display-time').textContent = "0.00s"; paths = []; currentPath = []; lastPoint = null; hasStarted = false; runCompleted = false; titans.forEach(t => { t.dead = false; t.skullScale = 0; }); updateUI(); }

    function generate() {
        resetRun(); titans = [];
        const sectors = [{ x: 120, y: 410, w: 160, h: 220, weight: 0.15 }, { x: 300, y: 410, w: 180, h: 220, weight: 0.15 }, { x: 520, y: 410, w: 140, h: 250, weight: 0.15 }, { x: 680, y: 410, w: 100, h: 250, weight: 0.15 }, { x: 150, y: 50,  w: 600, h: 320, weight: 0.40 }];
        const count = parseInt(document.getElementById('spawnCount').value) || 40;
        sectors.forEach(s => {
            const sc = Math.floor(count * s.weight);
            for(let i=0; i < sc; i++) {
                let pt = {x: 0, y: 0}, v = false, att = 0;
                while(!v && att < 50) { pt.x = s.x + (Math.random() * s.w); pt.y = s.y + (Math.random() * s.h); if (isPointInPoly(pt, missionPoly)) v = true; att++; }
                if(v) titans.push({ x: pt.x, y: pt.y, type: Math.random() < 0.8 ? 'basic' : 'abnormal', dead: false, skullScale: 0 });
            }
        });
        updateUI(); setMode('odm');
    }

    function draw() {
        ctx.clearRect(0,0,800,800);
        ctx.drawImage(imgs.map, 0, 0, 800, 800);
        if(grid) ctx.drawImage(imgs.grid, 0, 0, 800, 800);
        if (!hasStarted && !customMode) { ctx.strokeStyle = "rgba(0, 212, 255, 0.4)"; ctx.lineWidth = 2; ctx.strokeRect(startZone.x, startZone.y, startZone.w, startZone.h); }
        if (lastPoint && !runCompleted) { ctx.fillStyle = "#ff4757"; ctx.beginPath(); ctx.arc(lastPoint.x, lastPoint.y, 6, 0, Math.PI * 2); ctx.fill(); }
        titans.forEach(t => {
            ctx.drawImage(t.type === 'basic' ? imgs.basic : imgs.abnormal, t.x-15, t.y-15, 30, 30);
            if(t.dead) { if(t.skullScale > 1.0) t.skullScale -= 0.15; const s = 24 * t.skullScale; ctx.drawImage(imgs.skull, t.x - s/2, t.y - s/2, s, s); }
        });
        ctx.strokeStyle = "#00d4ff"; ctx.lineWidth = 3; ctx.lineCap = "round";
        [...paths, currentPath].forEach(p => { if(p.length < 2) return; ctx.beginPath(); ctx.moveTo(p[0].x, p[0].y); p.forEach(pt => ctx.lineTo(pt.x, pt.y)); ctx.stroke(); });
        requestAnimationFrame(draw);
    }

    function setMode(m) { customMode = (m === 'place'); updateUI(); }
    function updateUI() { 
        document.getElementById('titan-count').textContent = titans.filter(t => !t.dead).length;
        document.getElementById('btn-place').className = customMode ? 'btn-active' : '';
        document.getElementById('btn-odm').className = !customMode ? 'btn-active' : '';
        updateSync(); 
    }
    function updateSync() { const k = titans.filter(t => t.dead).length; document.getElementById('sync-val').textContent = titans.length > 0 ? Math.floor((k / titans.length) * 100) : 0; }
    function distToSeg(p,v,w){ const l2 = Math.pow(v.x-w.x, 2) + Math.pow(v.y-w.y, 2); if(l2 == 0) return Math.hypot(p.x-v.x, p.y-v.y); let t = Math.max(0, Math.min(1, ((p.x-v.x)*(w.x-v.x) + (p.y-v.y)*(w.y-v.y))/l2)); return Math.hypot(p.x-(v.x+t*(w.x-v.x)), p.y-(v.y+t*(w.y-v.y))); }
    function toggleGrid() { grid = !grid; }
    
    // Fixed: Ultra-compact Export
    function exportPreset() { 
        const s = titans.map(t => `${Math.round(t.x)}.${Math.round(t.y)}.${t.type === 'basic' ? 0 : 1}`).join(',');
        prompt("Copy Data:", s); 
    }

    // Fixed: Compact Import
    function importPreset() { 
        const c = prompt("Paste Data:"); 
        if(!c) return; 
        try { 
            titans = c.split(',').map(item => {
                const [x, y, type] = item.split('.');
                return { x: parseInt(x), y: parseInt(y), type: type === '0' ? 'basic' : 'abnormal', dead: false, skullScale: 0 };
            });
            resetRun(); 
        } catch(e){ alert("Invalid Data Format"); } 
    }

    function exportImage() { const tc = document.createElement('canvas'); tc.width = tc.height = 800; const t = tc.getContext('2d'); t.drawImage(canvas, 0, 0); const l = document.createElement('a'); l.download = 'Map_Export.png'; l.href = tc.toDataURL(); l.click(); }

    imgs.map.onload = () => { generate(); draw(); };
    canvas.oncontextmenu = (e) => e.preventDefault();
</script>
</body>
</html>
